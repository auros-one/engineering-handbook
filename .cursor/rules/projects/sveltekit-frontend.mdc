---
description: Apply when implementing frontend features with SvelteKit - includes patterns for API queries, mutations, state management, and component design
globs: 
alwaysApply: false
---
# SvelteKit Frontend Guidelines

This project uses Django for the backend and SvelteKit for the frontend.

When creating an end-to-end feature:

1. Sync the backend types with the frontend types by running `npm run sync-types`
    - If you just updated the backend code the dev server will automatically restart and probably need 5-10 seconds to be ready so then you might want to sleep for 5 seconds. And so also, if you run `npm run sync-types` and get an error, wait for 5 seconds and try again. Probably the backend was just restarted. If issues persist, something might be wrong with the backend. Run 'pytest' in the backend to check. If all tests pass but `sync-types` still fails, stop and ask for help.
2. Inspect existing frontend code to see how it's organized, where the new scope/feature will fit in, and how the existing UI/UX is designed and styled
3. Reason about the best way to implement the scope or feature; code organisation and UI/UX
4. Create or update the frontend code
5. Run type checking with `npm run check` and linting with `npm run lint`

Try to stay consistent with the project's style and best practices. So if you write any of these files from scratch, first inspect existing files to see how those are written to make sure you stay consistent with the project. Eg if you create a new views.py file to do this and don't have other examples in your context yet, first inspect existing views.py files to see how those are written to make sure you stay consistent with the project.

# Frontend API queries (tanstack query + openapi-fetch)

Tanstack query is used to fetch data from the backend and provide caching.

We use openapi-fetch to generate typescript client for our backend API. You can find the generated types in the project/lib/api/backend-api-schema.d.ts file, this is a very large file so you can grep for the relevant types. We added some middleware to the openapi-fetch client to automatically add authentication, if you need to inspect that, you can find the file by grepping for 'createClient'

## Query example
```+page.svelte
<script lang="ts">
    import type { components } from '$lib/api/backend-api-schema';
    import { createQuery, useQueryClient } from '@tanstack/svelte-query';
    import { apiClient } from '$lib/api';
    import Spinner from '$lib/components/loading/Spinner.svelte';

    // 1. Type Definition (if needed)
    type ResponseType = components['schemas']['YourSchemaType'];  // Use backend schema types
    // eg: type UserDetails = components['schemas']['UserDetails'];
    // eg: type PaginatedUserListList = components['schemas']['PaginatedUserListList'];
    type ErrorType = Error;  // Optional, defaults to unknown

    // 2. Query Client (if needed for cache invalidation)
    const queryClient = useQueryClient();

    // 3. Create Query Implementation
    const query = createQuery<ResponseType, ErrorType>({
        queryKey: ['uniqueKey', optionalId],
        queryFn: async () => {
            const { data, error } = await apiClient.GET('/your/endpoint/', {
                params: {
                    path: {
                        id: optionalId
                    },
                    query: {
                        page: pageNumber,
                    }
                }
            });

            if (error) throw new Error(error);
            if (!data) throw new Error('No data returned');

            return data;
        },
        staleTime: 5 * 60 * 1000,
        cacheTime: 10 * 60 * 1000,
        enabled: Boolean(optionalId),
        retry: 3,
    });

    // 4. Using the Query Results
    $: data = $query.data;
    $: isLoading = $query.isPending;
    $: error = $query.error;

    // 5. Cache Invalidation (if needed)
    async function invalidateCache() {
        await queryClient.invalidateQueries({ queryKey: ['uniqueKey'] });
    }
</script>

<div class="relative flex flex-col">
    <!-- Loading State -->
    {#if $query.isPending}
        <div class="flex h-[60vh] w-full items-center justify-center">
            <Spinner />
        </div>
    <!-- Error State -->
    {:else if $query.error}
        <div class="flex flex-col items-center justify-center gap-4 rounded-lg bg-red-50 p-6 text-red-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <p class="text-lg font-semibold">An error occurred: {$query.error.message}</p>
        </div>
    <!-- Success State -->
    {:else if $query.isSuccess}
        <div class="space-y-6">
            <!-- Example of data display -->
            {#if $query.data}
                <div class="rounded-lg bg-white p-6 shadow-sm">
                    <!-- Your data display here -->
                    <pre class="whitespace-pre-wrap text-sm text-gray-700">
                        {JSON.stringify($query.data, null, 2)}
                    </pre>
                </div>

                <!-- Example of refresh button -->
                <button
                    on:click={invalidateCache}
                    class="inline-flex items-center gap-2 rounded-md bg-primary-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Refresh Data
                </button>
            {/if}
        </div>
    {/if}
</div>
```

## Mutation example

```+page.svelte
<script lang="ts">
    import type { components } from '$lib/api/backend-api-schema';
    import { createMutation, useQueryClient } from '@tanstack/svelte-query';
    import { apiClient } from '$lib/api';
    import toast from 'svelte-french-toast';
    import Spinner from '$lib/components/loading/Spinner.svelte';

    // 1. Type Definitions
    type MutationRequest = {
        id: string;
        data: any;  // Replace with your specific type
    };
    type MutationResponse = components['schemas']['YourResponseType'];

    // 2. Query Client for cache updates
    const queryClient = useQueryClient();

    // 3. Create Mutation Implementation
    const mutation = createMutation({
        // Required: The mutation function
        mutationFn: async ({ id, data }: MutationRequest) => {
            const { data: responseData, error } = await apiClient.POST('/your/endpoint/{id}/', {
                params: {
                    path: {
                        id: id
                    }
                },
                body: data
            });

            if (error) {
                // Use toast for error feedback
                toast.error(error.error || 'An error occurred');
                throw new Error(error.error || 'An error occurred');
            }

            return responseData;
        },

        // Optional: Before mutation starts
        onMutate: async (variables) => {
            // Cancel any outgoing refetches
            await queryClient.cancelQueries({ queryKey: ['yourQueryKey'] });

            // Snapshot the previous value
            const previousData = queryClient.getQueryData(['yourQueryKey']);

            // Optimistically update the cache
            queryClient.setQueryData(['yourQueryKey'], (old: any) => ({
                ...old,
                // Your optimistic update
            }));

            // Return context with the snapshotted value
            return { previousData };
        },

        // Optional: On successful mutation
        onSuccess: async (data, variables) => {
            // Show success message
            toast.success('Operation successful!');

            // Invalidate and refetch relevant queries
            await queryClient.invalidateQueries({ queryKey: ['yourQueryKey'] });
        },

        // Optional: On mutation error
        onError: (error, variables, context) => {
            // Show error message
            toast.error('Operation failed');

            // Rollback to the previous value if available
            if (context?.previousData) {
                queryClient.setQueryData(['yourQueryKey'], context.previousData);
            }
        },

        // Optional: Run after either success or error
        onSettled: () => {
            // Clean up or final tasks
        }
    });

    // 4. Function to trigger the mutation
    async function handleMutation() {
        try {
            await $mutation.mutateAsync({
                id: 'your-id',
                data: { /* your data */ }
            });
        } catch (error) {
            console.error('Mutation error:', error);
        }
    }
</script>

<!-- 5. Usage in Template -->
<div class="space-y-4">
    <!-- Example of a form/button triggering the mutation -->
    <button
        on:click={handleMutation}
        disabled={$mutation.isPending}
        class="inline-flex items-center gap-2 rounded-md bg-primary-600 px-4 py-2 font-semibold text-white shadow-sm transition-colors duration-200 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
    >
        {#if $mutation.isPending}
            <Spinner color="white" size={18} ringThickness={1.5} />
            Processing...
        {:else}
            Submit
        {/if}
    </button>

    <!-- Loading State -->
    {#if $mutation.isPending}
        <div class="flex items-center gap-2 text-gray-600">
            <Spinner />
            <span>Processing your request...</span>
        </div>
    {/if}

    <!-- Error State -->
    {#if $mutation.isError}
        <div class="rounded-md bg-red-50 p-4 text-red-700">
            <p>Error: {$mutation.error.message}</p>
        </div>
    {/if}

    <!-- Success State -->
    {#if $mutation.isSuccess}
        <div class="rounded-md bg-green-50 p-4 text-green-700">
            <p>Operation completed successfully!</p>
        </div>
    {/if}
</div>
```

# Svelte 5 Runes Cheat (State Management)

## $state - Create reactive state
let count = $state<number>(0);
let user = $state<User>({ name: 'Alice', age: 30 });  // Deep reactivity
count++;  // Updates UI automatically
user.age++;  // Updates UI automatically

interface User {
  name: string;
  age: number;
}

## $state.raw - Non-proxied state (reassign only)
let list = $state.raw<number[]>([1, 2, 3]);
list.push(4);  // NO EFFECT!
list = [...list, 4];  // Works - creates new array

## $state.snapshot - Create non-reactive snapshot
let snapshot = $state.snapshot<User>(user);  // Plain JS object

## $derived - Computed values
let count = $state<number>(0);
let doubled = $derived<number>(count * 2);  // Updates when count changes
let isEven = $derived<boolean>(count % 2 === 0);

## $derived.by - Complex computations
interface Stats {
  sum: number;
  average: number;
  max: number;
}

let stats = $derived.by<Stats>(() => {
  const sum = numbers.reduce((a, b) => a + b, 0);
  return {
    sum,
    average: sum / numbers.length,
    max: Math.max(...numbers)
  };
});

# Effects & Lifecycle

## $effect - Run side effects when dependencies change
let count = $state<number>(0);
$effect(() => {
  console.log(`Count changed to ${count}`);
  // Return cleanup function (optional)
  return () => console.log('Cleaning up');
});

## $effect.pre - Run before DOM updates
$effect.pre(() => {
  if (scrollable) scrollable.scrollTop = scrollable.scrollHeight;
});

## $effect.root - Create isolated effect scope
const cleanup = $effect.root(() => {
  $effect(() => { /* ... */ });
  return () => { /* cleanup */ };
});

# Component Props

## $props - Access component props
interface Props {
  message: string;
  count?: number;
}

let { message, count = 0 }: Props = $props<Props>();
let { super: renamed, ...rest } = $props<{ super: string, [key: string]: any }>();

## $bindable - Two-way bindable props
interface InputProps {
  value?: string;
}

let { value = $bindable<string>('') }: InputProps = $props<InputProps>();

## $props.id - Generate unique component ID
const uid = $props.id();
<label for={`${uid}-input`}>Name</label>
<input id={`${uid}-input`}>

# Debugging

## $inspect - Log when values change (dev only)
$inspect(count, message);  // Logs when either changes

## $inspect with custom handler
$inspect(count).with((type: 'init' | 'update', value: number) => {
  if (type === 'update') console.trace();
});

## $inspect.trace - Trace reactivity
$effect(() => {
  $inspect.trace('my-label');  // Label is optional
  doWork();
});

# Custom Elements

## $host - Access host element in custom elements
<svelte:options customElement="my-element" />

function dispatch<T>(name: string, detail?: T) {
  $host().dispatchEvent(new CustomEvent<T>(name, { detail }));
}